
var assert = require('assert')
var Q = require('q')
var txTools = require('tx-data')
var getTxInfo = txTools.getTxInfo
var Transform = require('readable-stream').Transform

module.exports = TxParser
util.inherits(TxParser, Transform)

function TxParser (opts) {
  Transform.call(this, { objectMode: true })
  if (opts.lookup) this.lookup = opts.lookup
}

TxParser.prototype._transform = function (tx, enc, cb) {
  var parsed = getTxInfo(tx, self.networkName, self.prefix)
  if (!parsed.data) return cb(null, parsed)

  var addrs = parsed.tx.addresses
  if (!this.lookup) return onlookedup()

  var allAddrs = addrs.from.concat(addrs.to)
  var lookups = allAddrs.map(function (f) {
    if (!f) return Q.reject()
    var promise = self.lookup(f, true) // private
    assert(Q.isPromiseAlike(promise), '"lookup" function should return a promise')
    return promise
  })

  Q.allSettled(lookups)
    .done(function (results) {
      results = results.map(function (r) {
        return r.value
      })

      results.slice(0, addrs.from.length)
        .some(function (result) {
          if (result) {
            parsed.from = result
            return true
          }
        })

      results.slice(addrs.from.length)
        .some(function (result) {
          if (result && parsed.from && parsed.from.key.value !== result.key.value) {
            parsed.to = result
            return true
          }
        })

      onlookedup()
    })

  function onlookedup () {
    if (parsed.type !== 'public') {
      parsed.encryptedKey = parsed.key.toString('hex')
      parsed.sharedKey = self._getSharedKey(parsed)
      if (!parsed.sharedKey) return

      try {
        parsed.key = utils.decrypt(parsed.key, parsed.sharedKey)
        parsed.permissionKey = parsed.key
      } catch (err) {
        debug('Failed to decrypt permission key: ' + parsed.key)
        return
      }
    }

    parsed.key = parsed.key.toString('hex')
    if (parsed.permissionKey) {
      parsed.permissionKey = parsed.permissionKey.toString('hex')
    }

    cb(null, parsed)
  }
}
