
// var util = require('util')
// var Duplex = require('readable-stream').Duplex;

// function SimpleDuplex(options) {
//   Duplex.call(this, options); // init
//   // this.readArr = []
// }

// util.inherits(SimpleDuplex, Duplex);

// SimpleDuplex.prototype._read = function readBytes(n) {
//   // var self = this;
//   // while (this.readArr.length) {
//   //   var chunk = this.readArr.shift();
//   //   if (!self.push(chunk)) {
//   //     break; // false from push, stop reading
//   //   }
//   // }

//   // if (self.timer) { // continuing if have timer
//   //   // call readBytes again after a second has
//   //   // passed to see if more data then
//   //   setTimeout(readBytes.bind(self), 1000, n);
//   // } else { // we are done, push null to end stream
//     // self.push(null);
//   // }
// };

// /* stops the timer and ends the read stream */
// // SimpleDuplex.prototype.stopTimer = function () {
// //   if (this.timer) clearInterval(this.timer);
// //   this.timer = null;
// // };

// /* for write stream just ouptut to stdout */
// SimpleDuplex.prototype._write = function (chunk, enc, cb) {
//   console.log('write: ', chunk.toString());
//   this.push(chunk)
//   cb();
// };

// SimpleDuplex.prototype._flush = function (chunk, enc, cb) {
// }


// // try out SimpleDuplex
// var d = new SimpleDuplex();
// ;['connect', 'finish', 'end', 'close', 'flush'].forEach(function (event) {
//   d.on(event, function () {
//     console.log(event)
//   })
// })

// // d.on('readable', function () {
// //   var chunk;
// //   while (null !== (chunk = d.read())) {
// //     console.log('read: ', chunk.toString());
// //   }
// // });

// d.write('Hello \n');
// d.write('World');
// // d.push(null)
// d.end();

// // after 3 seconds stop the timer
// // setTimeout(function () {
// //   d.stopTimer();
// // }, 3000);

var Readable = require('readable-stream').Readable;
var crypto = require('crypto');
var shasum = crypto.createHash('sha1');
// ;['connect', 'finish', 'end', 'close', 'flush'].forEach(function (event) {
//   shasum.on(event, function () {
//     console.log(event)
//   })
// })

var r = new Readable
;['connect', 'finish', 'end', 'close', 'flush'].forEach(function (event) {
  r.on(event, function () {
    console.log(event)
  })
})

console.log('1')
r.push(new Buffer('blah blah blah'))
console.log('2')
r.push(null)
console.log('3')
// r.pipe(shasum).pipe(process.stdout)
process.nextTick(console.log.bind(console, '4'))
