
var util = require('util')
var Duplex = require('readable-stream').Duplex
var debug = require('debug')('SymmetricClient')
var safe = require('safecb')
var net = require('./')

module.exports = Client

function Client (port) {
  var self = this

  Duplex.call(this, {
    allowHalfOpen: false
  })

  this._port = port
  this._cxn = null
  this._queue = []
  this._server = net.createServer(function (c) {
    self._debug('inbound connection')
    c.once('close', function () {
      self.close()
      self._debug('closed inbound connection')
    })

    c.on('data', function (data) {
      self.push(data)
    })

    if (!self._cxn) {
      var addr = c.address()
      self.connect(addr.port, addr.address)
    }
  })

  this._server.listen(port)
}

util.inherits(Client, Duplex)

Client.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args.unshift(this._port)
  return debug.apply(null, args)
}

Client.prototype.connect = function (port, host) {
  var self = this
  if (this._closed) throw new Error('closed')
  if (this._cxn || this._connecting) return

  this._connecting = true
  this._debug('new outbound connection')
  this._cxn = net.connect({
    localPort: this._port,
    port: port,
    host: host
  })

  this._cxn.once('close', function () {
    self.close()
    self._cxn = null
    self._debug('closed outbound connection')
  })

  return this._cxn
}

Client.prototype.send = function (data) {
  if (this._closing) throw new Error('closing')
  if (!this._cxn) return this._queue.push(data)

  this.write(data)
}

Client.prototype._read = function () {
  // do nothing
}

Client.prototype._write = function (data, enc, cb) {
  this._cxn.write.apply(this._cxn, arguments)
}

Client.prototype.close = function (cb) {
  var self = this
  cb = safe(cb)
  if (this._closed) return cb()

  this.once('close', cb)
  if (this._closing) return

  this._closing = true
  if (this._cxn) this._cxn.destroy()
  if (this._server) this._server.close(emitClose)
  else emitClose()

  function emitClose () {
    self._closed = true
    self.emit('close')
  }
}
