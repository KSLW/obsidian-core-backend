
var fs = require('fs')
var OTR = require('./').OTR
var DSA = require('./').DSA
var users = {
  bill: {},
  ted: {}
}

Object.keys(users).forEach(function(name) {
  var otherName = Object.keys(users).filter(function(n) { return n !== name })[0]
  var otherUser = users[otherName]
  var user = users[name]
  var keyFile = './' + name + '.dsa'
  var key
  if (fs.existsSync(keyFile)) {
    key = DSA.parsePrivate(fs.readFileSync(keyFile).toString())
  }
  else {
    key = new DSA()
    fs.writeFile(keyFile, key.packPrivate())
  }

  user.key = key

  var myOTR = user.otr = new OTR({
    priv: key,
    debug: true,
    fragment_size: 140,
    send_interval: 200
  })

  myOTR.REQUIRE_ENCRYPTION = true

  // myOTR.on('status', function(status) {
  //   if (status === OTR.CONST.STATUS_AKE_SUCCESS) {
  //     console.log(myOTR.their_priv_pk.fingerprint() === otherUser.key.fingerprint())
  //   }
  // })

  myOTR.on('ui', function (msg, encrypted, meta) {

    // console.log('sending a msg back')
    // debugger;
    console.log(otherName + (encrypted ? ' (encrypted)' : '') + ': ' + msg)
    if (msg.indexOf('yourself') !== -1) return

    myOTR.sendMsg(msg + ' yourself!', 'some ' + name + 'adata')
    // // encrypted === true, if the received msg was encrypted
    // console.log("(optional) with receiveMsg attached meta data: " + meta)
  })

  myOTR.on('io', function (msg, meta) {
    otherUser.otr.receiveMsg(msg, meta)
    // console.log("message to send to buddy: " + msg)
    // console.log("(optional) with sendMsg attached meta data: " + meta)
  })

  myOTR.on('error', function (err, severity) {
    // if (severity === 'error')  // either 'error' or 'warn'
      console.error("error occurred: " + err)
  })

  myOTR.on('status', function (state) {
    switch (state) {
      case OTR.CONST.STATUS_AKE_SUCCESS:
        console.log('sucessfully ake\'d with buddy')
        // check if buddy.msgstate === OTR.CONST.MSGSTATE_ENCRYPTED
        break
      case OTR.CONST.STATUS_END_OTR:
        if (myOTR.msgstate === OTR.CONST.MSGSTATE_FINISHED) {
          // inform the user that his correspondent has closed his end
          // of the private connection and the user should do the same
        }
        break
    }
  })
})

users.bill.otr.sendMsg('hello ted', 'some billadata')
users.ted.otr.sendMsg('hello bill', 'some tedadata')

// setTimeout(function() {
//   users.bill.otr.sendMsg('you there, ted?', 'some more billadata')
// }, 5000)
